# ============================================================================
# Advent of Code 2024 Day 14 - Part 2
# Problem: Count how many times a robot passes through position 0 while
# moving on a circular track (0-99 positions)
# 
# Key insight: We count every crossing of the 0-boundary, not just landings
# Example: from position 50, move right 68
#   - Passes through positions 51-99 (99 total), wraps to 0, continues 1-18
#   - Crosses position 0 exactly once
# ============================================================================

# Initialize state with starting position 50 and zero crossings counter
let initial_state = {position: 50, times_at_zero: 0} in

# Process a single line of movement data
# Input format: direction (R=right, L=left) followed by amount
# Returns: updated state with new position and crossing count
let process_line = \state \line
  # Skip empty lines (no movement needed)
  if is_empty (trim line) then
    state
  else
    # Parse the input line using regex scan
    # Matches "R" or "L" followed by digits
    let parts = scan "[RL]|\\d+" line in
    let dir = head parts in
    let amount = to_int (head (tail parts)) in
    
    # Extract current state values
    let current_position = to_int (get state "position") in
    let current_times = to_int (get state "times_at_zero") in
    
    # Calculate raw position before wrapping (can be negative or > 99)
    let new_position_raw = if dir == "R" then 
      current_position + amount 
    else 
      current_position - amount 
    in
    
    # Count how many times we cross the 0-boundary during this movement
    # The track is circular: after 99 comes 0, before 0 comes 99
    # We count crossings by checking 100-position quotients
    let times_at_zero = if dir == "R" then
      # Moving RIGHT: check if we cross from [0-99] to [100+]
      # Quotient increases when we pass a multiple of 100
      let end_div = (current_position + amount) / 100 in
      let start_div = current_position / 100 in
      end_div - start_div
    else
      # Moving LEFT: handle wrapping around from 0 to 99
      let end_raw = current_position - amount in
      if end_raw < 0 then
        # We went negative, so we definitely wrapped to the high end (99, 98, ...)
        # and crossed through 0 at least once
        # Formula: 1 (for the wrap) + extra wraps for large left movements
        1 + (abs (end_raw + 1)) / 100
      else
        # No wrapping, but we might have crossed a 100-boundary going left
        let start_div = current_position / 100 in
        let end_div = end_raw / 100 in
        start_div - end_div
    in
    
    # Add the crossings from this movement to the total count
    let incremented_times = current_times + times_at_zero in
    
    # Wrap the final position to stay in range [0, 99]
    let k = new_position_raw in
    let final_position = if k < 0 then 
      # Negative position: add 100 to wrap around
      100 + (k % 100)
    else if k > 99 then
      # Position >= 100: use modulo to wrap
      k % 100
    else
      # Already in valid range
      k
    in
    
    # Return updated state with new position and total crossing count
    {position: final_position, times_at_zero: incremented_times}
in

# Read all movement instructions from the data file
let input_lines = readlines @data.txt in

# Process each line sequentially, accumulating state
# fold() applies process_line to each line, threading the state through
let final_state = fold process_line initial_state input_lines in

# Output the final result: total times the robot crossed position 0
trace "Times at zero" (get final_state "times_at_zero")
